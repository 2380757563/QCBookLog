# QC Booklog Docker æ”¹è¿›æ–¹æ¡ˆ

æœ¬æ–‡æ¡£æä¾›äº†æ”¹è¿›QC Booklogé¡¹ç›®ä»¥æ›´å¥½åœ°æ”¯æŒDockeréƒ¨ç½²çš„å»ºè®®å’Œæ–¹æ¡ˆã€‚

## ç›®å½•

- [å½“å‰é—®é¢˜åˆ†æ](#å½“å‰é—®é¢˜åˆ†æ)
- [ä»£ç æ”¹è¿›å»ºè®®](#ä»£ç æ”¹è¿›å»ºè®®)
- [é…ç½®æ”¹è¿›å»ºè®®](#é…ç½®æ”¹è¿›å»ºè®®)
- [æ¶æ„æ”¹è¿›å»ºè®®](#æ¶æ„æ”¹è¿›å»ºè®®)
- [å®æ–½ä¼˜å…ˆçº§](#å®æ–½ä¼˜å…ˆçº§)

## å½“å‰é—®é¢˜åˆ†æ

### 1. ç¡¬ç¼–ç è·¯å¾„é—®é¢˜

**é—®é¢˜æè¿°**:
- åç«¯ä»£ç ä¸­ç¡¬ç¼–ç äº†æ•°æ®åº“è·¯å¾„ï¼š`D:\anz\calibre`
- æ—¥å¿—è·¯å¾„ç¡¬ç¼–ç ï¼š`../data/logs/app.log`
- ä¸æ”¯æŒè·¨å¹³å°éƒ¨ç½²

**å½±å“**:
- æ— æ³•åœ¨ä¸åŒç¯å¢ƒï¼ˆLinux/Macï¼‰ä¸­éƒ¨ç½²
- éœ€è¦ä¿®æ”¹ä»£ç æ‰èƒ½æ›´æ”¹è·¯å¾„
- è¿å12-Factoråº”ç”¨åŸåˆ™

### 2. ç¼ºå°‘é…ç½®ç®¡ç†

**é—®é¢˜æè¿°**:
- æ²¡æœ‰ç»Ÿä¸€çš„é…ç½®ç®¡ç†æ–¹æ¡ˆ
- ç¯å¢ƒå˜é‡ä½¿ç”¨ä¸ç»Ÿä¸€
- ç¼ºå°‘é…ç½®éªŒè¯

**å½±å“**:
- é…ç½®åˆ†æ•£ï¼Œéš¾ä»¥ç»´æŠ¤
- å®¹æ˜“å‡ºç°é…ç½®é”™è¯¯
- ä¸æ”¯æŒå¤šç¯å¢ƒé…ç½®

### 3. æ•°æ®æŒä¹…åŒ–ä¸å®Œå–„

**é—®é¢˜æè¿°**:
- æ•°æ®åº“æ–‡ä»¶ç›´æ¥åœ¨å®¿ä¸»æœºä¸Š
- ç¼ºå°‘æ•°æ®å¤‡ä»½æœºåˆ¶
- æ²¡æœ‰æ•°æ®è¿ç§»æ–¹æ¡ˆ

**å½±å“**:
- æ•°æ®å®‰å…¨é£é™©
- å‡çº§å›°éš¾
- æ— æ³•è½»æ¾è¿ç§»æ•°æ®

### 4. ç¼ºå°‘å¥åº·æ£€æŸ¥

**é—®é¢˜æè¿°**:
- åç«¯æ²¡æœ‰å¥åº·æ£€æŸ¥ç«¯ç‚¹
- å‰ç«¯æ²¡æœ‰å¥åº·æ£€æŸ¥
- æ— æ³•è‡ªåŠ¨æ£€æµ‹æœåŠ¡å¼‚å¸¸

**å½±å“**:
- éœ€è¦æ‰‹åŠ¨æ£€æŸ¥æœåŠ¡çŠ¶æ€
- æ•…éšœæ¢å¤æ—¶é—´é•¿
- ç›‘æ§å›°éš¾

### 5. æ—¥å¿—ç®¡ç†ä¸å®Œå–„

**é—®é¢˜æè¿°**:
- æ—¥å¿—æ–‡ä»¶ç›´æ¥å†™å…¥æ–‡ä»¶ç³»ç»Ÿ
- æ²¡æœ‰æ—¥å¿—è½®è½¬
- ç¼ºå°‘ç»“æ„åŒ–æ—¥å¿—

**å½±å“**:
- æ—¥å¿—æ–‡ä»¶å¯èƒ½è¿‡å¤§
- éš¾ä»¥æŸ¥è¯¢å’Œåˆ†ææ—¥å¿—
- ä¸ç¬¦åˆæœ€ä½³å®è·µ

## ä»£ç æ”¹è¿›å»ºè®®

### 1. åˆ›å»ºé…ç½®ç®¡ç†æ¨¡å—

**ç›®æ ‡**: ç»Ÿä¸€ç®¡ç†æ‰€æœ‰é…ç½®ï¼Œæ”¯æŒç¯å¢ƒå˜é‡å’Œé…ç½®æ–‡ä»¶

**å®æ–½æ­¥éª¤**:

#### 1.1 åˆ›å»ºé…ç½®æ–‡ä»¶ç»“æ„

```typescript
// server/config/index.ts
export interface AppConfig {
  // æœåŠ¡å™¨é…ç½®
  port: number;
  host: string;
  nodeEnv: string;

  // æ•°æ®åº“é…ç½®
  calibreDbPath: string;
  talebookDbPath: string;

  // æ—¥å¿—é…ç½®
  logLevel: string;
  logPath: string;
  maxLogFiles: number;
  maxLogSize: string;

  // æ–‡ä»¶ä¸Šä¼ é…ç½®
  maxFileSize: number;
  uploadDir: string;

  // CORSé…ç½®
  corsOrigin: string;
  corsMethods: string[];
  corsHeaders: string[];

  // å®‰å…¨é…ç½®
  jwtSecret?: string;
  sessionSecret?: string;
}

export interface DatabaseConfig {
  calibre: {
    path: string;
    readonly: boolean;
  };
  talebook: {
    path: string;
    readonly: boolean;
  };
}
```

#### 1.2 å®ç°é…ç½®åŠ è½½å™¨

```typescript
// server/config/loader.ts
import { AppConfig, DatabaseConfig } from './index';
import dotenv from 'dotenv';
import path from 'path';

dotenv.config();

const getEnv = (key: string, defaultValue: string): string => {
  const value = process.env[key];
  if (value === undefined) {
    console.warn(`Environment variable ${key} is not set, using default: ${defaultValue}`);
    return defaultValue;
  }
  return value;
};

const getEnvNumber = (key: string, defaultValue: number): number => {
  const value = process.env[key];
  if (value === undefined) {
    return defaultValue;
  }
  const num = parseInt(value, 10);
  if (isNaN(num)) {
    console.warn(`Environment variable ${key} is not a valid number, using default: ${defaultValue}`);
    return defaultValue;
  }
  return num;
};

const getEnvBoolean = (key: string, defaultValue: boolean): boolean => {
  const value = process.env[key];
  if (value === undefined) {
    return defaultValue;
  }
  return value.toLowerCase() === 'true';
};

export const config: AppConfig = {
  // æœåŠ¡å™¨é…ç½®
  port: getEnvNumber('PORT', 7401),
  host: getEnv('HOST', '0.0.0.0'),
  nodeEnv: getEnv('NODE_ENV', 'production'),

  // æ•°æ®åº“é…ç½®
  calibreDbPath: getEnv('CALIBRE_DB_PATH', './data/calibre/metadata.db'),
  talebookDbPath: getEnv('TALEBOOK_DB_PATH', './data/calibre-webserver.db'),

  // æ—¥å¿—é…ç½®
  logLevel: getEnv('LOG_LEVEL', 'info'),
  logPath: getEnv('LOG_PATH', './data/logs'),
  maxLogFiles: getEnvNumber('MAX_LOG_FILES', 5),
  maxLogSize: getEnv('MAX_LOG_SIZE', '5m'),

  // æ–‡ä»¶ä¸Šä¼ é…ç½®
  maxFileSize: getEnvNumber('MAX_FILE_SIZE', 20),
  uploadDir: getEnv('UPLOAD_DIR', './data/uploads'),

  // CORSé…ç½®
  corsOrigin: getEnv('CORS_ORIGIN', '*'),
  corsMethods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  corsHeaders: ['Content-Type', 'Authorization'],

  // å®‰å…¨é…ç½®
  jwtSecret: getEnv('JWT_SECRET', ''),
  sessionSecret: getEnv('SESSION_SECRET', ''),
};

export const dbConfig: DatabaseConfig = {
  calibre: {
    path: config.calibreDbPath,
    readonly: true,
  },
  talebook: {
    path: config.talebookDbPath,
    readonly: false,
  },
};

// éªŒè¯å¿…éœ€çš„é…ç½®
export const validateConfig = (): boolean => {
  const requiredPaths = [
    { name: 'Calibre DB', path: config.calibreDbPath },
    { name: 'Talebook DB', path: config.talebookDbPath },
  ];

  for (const { name, path } of requiredPaths) {
    if (!path || path.trim() === '') {
      console.error(`âŒ ${name} path is required`);
      return false;
    }
  }

  return true;
};
```

#### 1.3 æ›´æ–°app.jsä½¿ç”¨é…ç½®

```javascript
// server/app.js
import express from 'express';
import cors from 'cors';
import { config, dbConfig, validateConfig } from './config';
import calibreService from './services/calibreService.js';

// éªŒè¯é…ç½®
if (!validateConfig()) {
  console.error('âŒ Configuration validation failed. Please check your environment variables.');
  process.exit(1);
}

// åˆ›å»ºExpressåº”ç”¨
const app = express();

// ä½¿ç”¨é…ç½®
const PORT = config.port;
const HOST = config.host;

// ä¸­é—´ä»¶é…ç½®
app.use(cors({
  origin: config.corsOrigin,
  methods: config.corsMethods,
  allowedHeaders: config.corsHeaders,
}));

app.use(express.json({ limit: `${config.maxFileSize}mb` }));
app.use(express.urlencoded({ extended: true }));

// åˆå§‹åŒ–æœåŠ¡
calibreService.initialize(dbConfig);

// å¯åŠ¨æœåŠ¡å™¨
app.listen(PORT, HOST, () => {
  console.log(`âœ… Server running on http://${HOST}:${PORT}`);
  console.log(`ğŸ“š Calibre DB: ${config.calibreDbPath}`);
  console.log(`ğŸ“š Talebook DB: ${config.talebookDbPath}`);
});
```

### 2. æ”¹è¿›æ—¥å¿—ç³»ç»Ÿ

**ç›®æ ‡**: å®ç°ç»“æ„åŒ–æ—¥å¿—ã€æ—¥å¿—è½®è½¬ã€å¤šçº§åˆ«æ—¥å¿—

**å®æ–½æ­¥éª¤**:

#### 2.1 åˆ›å»ºæ—¥å¿—é…ç½®

```typescript
// server/config/logger.ts
import winston from 'winston';
import path from 'path';
import { config } from './index';

const logFormat = winston.format.combine(
  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
  winston.format.errors({ stack: true }),
  winston.format.json()
);

const consoleFormat = winston.format.combine(
  winston.format.colorize(),
  winston.format.simple()
);

export const logger = winston.createLogger({
  level: config.logLevel,
  format: logFormat,
  defaultMeta: { service: 'qc-booklog-backend' },
  transports: [
    // æ–‡ä»¶ä¼ è¾“ï¼ˆå¸¦è½®è½¬ï¼‰
    new winston.transports.File({
      filename: path.join(config.logPath, 'app.log'),
      maxsize: config.maxLogSize,
      maxFiles: config.maxLogFiles,
      tailable: true,
    }),
    // é”™è¯¯æ—¥å¿—å•ç‹¬æ–‡ä»¶
    new winston.transports.File({
      filename: path.join(config.logPath, 'error.log'),
      level: 'error',
      maxsize: config.maxLogSize,
      maxFiles: config.maxLogFiles,
    }),
    // æ§åˆ¶å°è¾“å‡º
    new winston.transports.Console({
      format: config.nodeEnv === 'production' ? logFormat : consoleFormat,
    }),
  ],
});

// åˆ›å»ºå­æ—¥å¿—è®°å½•å™¨
export const createLogger = (module: string) => {
  return logger.child({ module });
};
```

#### 2.2 åœ¨æœåŠ¡ä¸­ä½¿ç”¨æ—¥å¿—

```javascript
// server/services/calibreService.js
import { createLogger } from '../config/logger';

const logger = createLogger('CalibreService');

export const getAllBooks = async () => {
  logger.info('å¼€å§‹è·å–æ‰€æœ‰ä¹¦ç±');
  try {
    const books = await queryBooks();
    logger.info(`æˆåŠŸè·å– ${books.length} æœ¬ä¹¦`);
    return books;
  } catch (error) {
    logger.error('è·å–ä¹¦ç±å¤±è´¥', { error: error.message, stack: error.stack });
    throw error;
  }
};
```

### 3. æ·»åŠ å¥åº·æ£€æŸ¥ç«¯ç‚¹

**ç›®æ ‡**: æä¾›å¥åº·æ£€æŸ¥ç«¯ç‚¹ï¼Œæ”¯æŒDockerå¥åº·æ£€æŸ¥

**å®æ–½æ­¥éª¤**:

```javascript
// server/routes/health.js
import express from 'express';
import { createLogger } from '../config/logger';
import databaseService from '../services/databaseService.js';

const logger = createLogger('HealthCheck');
const router = express.Router();

// åŸºæœ¬å¥åº·æ£€æŸ¥
router.get('/', async (req, res) => {
  try {
    // æ£€æŸ¥æ•°æ®åº“è¿æ¥
    const dbStatus = await databaseService.checkConnection();

    const health = {
      status: 'healthy',
      timestamp: new Date().toISOString(),
      uptime: process.uptime(),
      services: {
        database: dbStatus ? 'up' : 'down',
      },
    };

    const statusCode = dbStatus ? 200 : 503;
    res.status(statusCode).json(health);

    logger.info('å¥åº·æ£€æŸ¥', { status: health.status, db: dbStatus });
  } catch (error) {
    logger.error('å¥åº·æ£€æŸ¥å¤±è´¥', { error: error.message });
    res.status(503).json({
      status: 'unhealthy',
      timestamp: new Date().toISOString(),
      error: error.message,
    });
  }
});

// è¯¦ç»†å¥åº·æ£€æŸ¥
router.get('/detailed', async (req, res) => {
  try {
    const dbStatus = await databaseService.checkConnection();
    const diskUsage = await getDiskUsage();
    const memoryUsage = process.memoryUsage();

    const health = {
      status: 'healthy',
      timestamp: new Date().toISOString(),
      uptime: process.uptime(),
      services: {
        database: dbStatus ? 'up' : 'down',
      },
      system: {
        memory: {
          used: Math.round(memoryUsage.heapUsed / 1024 / 1024),
          total: Math.round(memoryUsage.heapTotal / 1024 / 1024),
          unit: 'MB',
        },
        disk: diskUsage,
      },
    };

    res.status(dbStatus ? 200 : 503).json(health);
  } catch (error) {
    res.status(503).json({
      status: 'unhealthy',
      error: error.message,
    });
  }
});

export default router;
```

#### 3.2 åœ¨app.jsä¸­æ³¨å†Œè·¯ç”±

```javascript
// server/app.js
import healthRouter from './routes/health';

app.use('/health', healthRouter);
```

### 4. å®ç°æ•°æ®å¤‡ä»½åŠŸèƒ½

**ç›®æ ‡**: æä¾›è‡ªåŠ¨æ•°æ®å¤‡ä»½å’Œæ¢å¤åŠŸèƒ½

**å®æ–½æ­¥éª¤**:

```javascript
// server/services/backupService.js
import fs from 'fs/promises';
import path from 'path';
import archiver from 'archiver';
import { createLogger } from '../config/logger';
import { config } from '../config';

const logger = createLogger('BackupService');

export const createBackup = async () => {
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const backupDir = path.join(config.logPath, 'backups');
  const backupFile = path.join(backupDir, `backup-${timestamp}.zip`);

  try {
    logger.info('å¼€å§‹åˆ›å»ºå¤‡ä»½', { backupFile });

    // ç¡®ä¿å¤‡ä»½ç›®å½•å­˜åœ¨
    await fs.mkdir(backupDir, { recursive: true });

    // åˆ›å»ºå¤‡ä»½
    const output = fs.createWriteStream(backupFile);
    const archive = archiver('zip', { zlib: { level: 9 } });

    output.on('close', () => {
      logger.info('å¤‡ä»½åˆ›å»ºæˆåŠŸ', { size: archive.pointer() });
    });

    archive.on('error', (err) => {
      logger.error('å¤‡ä»½å¤±è´¥', { error: err.message });
      throw err;
    });

    archive.pipe(output);

    // æ·»åŠ æ•°æ®åº“æ–‡ä»¶
    archive.file(config.calibreDbPath, 'calibre/metadata.db');
    archive.file(config.talebookDbPath, 'talebook/calibre-webserver.db');

    // æ·»åŠ æ•°æ®ç›®å½•
    archive.directory('./data', 'data');

    await archive.finalize();

    return backupFile;
  } catch (error) {
    logger.error('åˆ›å»ºå¤‡ä»½å¤±è´¥', { error: error.message });
    throw error;
  }
};

export const restoreBackup = async (backupFile: string) => {
  try {
    logger.info('å¼€å§‹æ¢å¤å¤‡ä»½', { backupFile });

    // éªŒè¯å¤‡ä»½æ–‡ä»¶
    await fs.access(backupFile, fs.constants.R_OK);

    // è§£å‹å¤‡ä»½
    const extract = require('extract-zip');
    await extract(backupFile, { dir: './data' });

    logger.info('å¤‡ä»½æ¢å¤æˆåŠŸ');
  } catch (error) {
    logger.error('æ¢å¤å¤‡ä»½å¤±è´¥', { error: error.message });
    throw error;
  }
};

export const cleanupOldBackups = async (keepDays = 7) => {
  try {
    const backupDir = path.join(config.logPath, 'backups');
    const files = await fs.readdir(backupDir);
    const now = Date.now();
    const maxAge = keepDays * 24 * 60 * 60 * 1000;

    for (const file of files) {
      const filePath = path.join(backupDir, file);
      const stats = await fs.stat(filePath);

      if (now - stats.mtimeMs > maxAge) {
        await fs.unlink(filePath);
        logger.info('åˆ é™¤æ—§å¤‡ä»½', { file });
      }
    }
  } catch (error) {
    logger.error('æ¸…ç†æ—§å¤‡ä»½å¤±è´¥', { error: error.message });
  }
};
```

### 5. æ·»åŠ APIæ–‡æ¡£

**ç›®æ ‡**: æä¾›å®Œæ•´çš„APIæ–‡æ¡£ï¼Œæ–¹ä¾¿å¼€å‘å’Œè°ƒè¯•

**å®æ–½æ­¥éª¤**:

```javascript
// server/routes/docs.js
import express from 'express';
import swaggerJsdoc from 'swagger-jsdoc';
import swaggerUi from 'swagger-ui-express';

const router = express.Router();

const options = {
  definition: {
    openapi: '3.0.0',
    info: {
      title: 'QC Booklog API',
      version: '1.0.0',
      description: 'QC Booklogåç«¯APIæ–‡æ¡£',
    },
    servers: [
      {
        url: 'http://localhost:7401',
        description: 'å¼€å‘æœåŠ¡å™¨',
      },
    ],
  },
  apis: ['./routes/*.js'],
};

const specs = swaggerJsdoc(options);

router.use('/', swaggerUi.serve);
router.get('/json', (req, res) => {
  res.setHeader('Content-Type', 'application/json');
  res.send(specs);
});

export default router;
```

## é…ç½®æ”¹è¿›å»ºè®®

### 1. åˆ›å»ºå¤šç¯å¢ƒé…ç½®

**ç›®æ ‡**: æ”¯æŒå¼€å‘ã€æµ‹è¯•ã€ç”Ÿäº§ç­‰å¤šç¯å¢ƒ

**å®æ–½**:

```bash
# .env.development
NODE_ENV=development
PORT=7401
LOG_LEVEL=debug
CALIBRE_DB_PATH=./data/calibre/metadata.db

# .env.production
NODE_ENV=production
PORT=7401
LOG_LEVEL=warn
CALIBRE_DB_PATH=/app/data/calibre/metadata.db

# .env.test
NODE_ENV=test
PORT=7402
LOG_LEVEL=error
CALIBRE_DB_PATH=./test/data/calibre/metadata.db
```

### 2. æ·»åŠ é…ç½®éªŒè¯

**ç›®æ ‡**: å¯åŠ¨æ—¶éªŒè¯æ‰€æœ‰å¿…éœ€é…ç½®

**å®æ–½**:

```typescript
// server/config/validator.ts
import { config } from './index';
import fs from 'fs/promises';

export const validatePaths = async (): Promise<boolean> => {
  const paths = [
    { name: 'Calibre DB', path: config.calibreDbPath },
    { name: 'Talebook DB', path: config.talebookDbPath },
    { name: 'Log directory', path: config.logPath },
  ];

  for (const { name, path } of paths) {
    try {
      await fs.access(path, fs.constants.R_OK);
      console.log(`âœ… ${name} path is accessible: ${path}`);
    } catch (error) {
      console.error(`âŒ ${name} path is not accessible: ${path}`);
      return false;
    }
  }

  return true;
};

export const validatePorts = (): boolean => {
  const port = config.port;
  if (port < 1 || port > 65535) {
    console.error(`âŒ Invalid port number: ${port}`);
    return false;
  }

  console.log(`âœ… Port ${port} is valid`);
  return true;
};

export const validateAll = async (): Promise<boolean> => {
  const pathsValid = await validatePaths();
  const portsValid = validatePorts();

  return pathsValid && portsValid;
};
```

### 3. æ·»åŠ é…ç½®çƒ­é‡è½½

**ç›®æ ‡**: æ”¯æŒä¸é‡å¯æœåŠ¡é‡æ–°åŠ è½½é…ç½®

**å®æ–½**:

```javascript
// server/config/hotReload.js
import chokidar from 'chokidar';
import { createLogger } from './logger';

const logger = createLogger('ConfigHotReload');

export const watchConfig = () => {
  const watcher = chokidar.watch('.env');

  watcher.on('change', async () => {
    logger.info('æ£€æµ‹åˆ°é…ç½®æ–‡ä»¶å˜æ›´ï¼Œé‡æ–°åŠ è½½é…ç½®...');

    try {
      // é‡æ–°åŠ è½½ç¯å¢ƒå˜é‡
      delete require.cache[require.resolve('dotenv')];
      require('dotenv').config();

      // é‡æ–°åŠ è½½é…ç½®
      const { config } = await import('./index');

      logger.info('é…ç½®é‡æ–°åŠ è½½æˆåŠŸ', {
        port: config.port,
        logLevel: config.logLevel,
      });
    } catch (error) {
      logger.error('é…ç½®é‡æ–°åŠ è½½å¤±è´¥', { error: error.message });
    }
  });
};
```

## æ¶æ„æ”¹è¿›å»ºè®®

### 1. å¾®æœåŠ¡åŒ–

**ç›®æ ‡**: å°†åº”ç”¨æ‹†åˆ†ä¸ºç‹¬ç«‹çš„å¾®æœåŠ¡

**å»ºè®®çš„å¾®æœåŠ¡**:

```
qc-booklog/
â”œâ”€â”€ frontend/          # å‰ç«¯æœåŠ¡
â”œâ”€â”€ api/              # APIç½‘å…³
â”œâ”€â”€ book-service/      # ä¹¦ç±æœåŠ¡
â”œâ”€â”€ user-service/      # ç”¨æˆ·æœåŠ¡
â”œâ”€â”€ reading-service/  # é˜…è¯»æœåŠ¡
â”œâ”€â”€ backup-service/    # å¤‡ä»½æœåŠ¡
â””â”€â”€ monitoring/        # ç›‘æ§æœåŠ¡
```

### 2. æ·»åŠ æ¶ˆæ¯é˜Ÿåˆ—

**ç›®æ ‡**: ä½¿ç”¨æ¶ˆæ¯é˜Ÿåˆ—å¤„ç†å¼‚æ­¥ä»»åŠ¡

**å»ºè®®**:

```javascript
// ä½¿ç”¨Redisæˆ–RabbitMQ
import { Queue } from 'bullmq';

const backupQueue = new Queue('backup', {
  connection: redisConfig,
});

backupQueue.process('create-backup', async (job) => {
  await createBackup(job.data);
});
```

### 3. å®ç°ç¼“å­˜å±‚

**ç›®æ ‡**: å‡å°‘æ•°æ®åº“æŸ¥è¯¢ï¼Œæé«˜æ€§èƒ½

**å»ºè®®**:

```javascript
// ä½¿ç”¨Redisç¼“å­˜
import Redis from 'ioredis';

const redis = new Redis();

export const getCachedBooks = async (key: string) => {
  const cached = await redis.get(key);
  if (cached) {
    return JSON.parse(cached);
  }

  const books = await databaseService.getAllBooks();
  await redis.setex(key, 3600, JSON.stringify(books));
  return books;
};
```

### 4. æ·»åŠ ç›‘æ§å’Œå‘Šè­¦

**ç›®æ ‡**: å®æ—¶ç›‘æ§åº”ç”¨çŠ¶æ€ï¼Œå¼‚å¸¸å‘Šè­¦

**å»ºè®®**:

```javascript
// ä½¿ç”¨Prometheus + Grafana
import promClient from 'prom-client';

const httpRequestDuration = new promClient.Histogram({
  name: 'http_request_duration_seconds',
  help: 'Duration of HTTP requests in seconds',
  labelNames: ['method', 'route', 'code'],
});

app.use((req, res, next) => {
  const start = Date.now();
  res.on('finish', () => {
    const duration = (Date.now() - start) / 1000;
    httpRequestDuration
      .labels(req.method, req.route, res.statusCode)
      .observe(duration);
  });
  next();
});
```

## å®æ–½ä¼˜å…ˆçº§

### é«˜ä¼˜å…ˆçº§ï¼ˆç«‹å³å®æ–½ï¼‰

1. âœ… **é…ç½®ç®¡ç†æ¨¡å—** - è§£å†³ç¡¬ç¼–ç é—®é¢˜
2. âœ… **å¥åº·æ£€æŸ¥ç«¯ç‚¹** - æ”¯æŒDockerå¥åº·æ£€æŸ¥
3. âœ… **æ—¥å¿—ç³»ç»Ÿæ”¹è¿›** - ç»“æ„åŒ–æ—¥å¿—ã€æ—¥å¿—è½®è½¬
4. âœ… **ç¯å¢ƒå˜é‡éªŒè¯** - å¯åŠ¨æ—¶éªŒè¯é…ç½®

### ä¸­ä¼˜å…ˆçº§ï¼ˆè¿‘æœŸå®æ–½ï¼‰

1. **æ•°æ®å¤‡ä»½åŠŸèƒ½** - è‡ªåŠ¨å¤‡ä»½å’Œæ¢å¤
2. **APIæ–‡æ¡£** - Swagger/OpenAPIæ–‡æ¡£
3. **å¤šç¯å¢ƒé…ç½®** - å¼€å‘/æµ‹è¯•/ç”Ÿäº§ç¯å¢ƒ
4. **é”™è¯¯å¤„ç†æ”¹è¿›** - ç»Ÿä¸€é”™è¯¯å¤„ç†å’Œå“åº”

### ä½ä¼˜å…ˆçº§ï¼ˆé•¿æœŸè§„åˆ’ï¼‰

1. **å¾®æœåŠ¡åŒ–** - æ ¹æ®ä¸šåŠ¡éœ€æ±‚æ‹†åˆ†æœåŠ¡
2. **æ¶ˆæ¯é˜Ÿåˆ—** - å¤„ç†å¼‚æ­¥ä»»åŠ¡
3. **ç¼“å­˜å±‚** - æé«˜æ€§èƒ½
4. **ç›‘æ§å‘Šè­¦** - å®æ—¶ç›‘æ§å’Œå‘Šè­¦

## æ€»ç»“

é€šè¿‡å®æ–½ä»¥ä¸Šæ”¹è¿›å»ºè®®ï¼ŒQC Booklogé¡¹ç›®å°†è·å¾—ï¼š

1. **æ›´å¥½çš„å¯ç»´æŠ¤æ€§** - ç»Ÿä¸€çš„é…ç½®ç®¡ç†
2. **æ›´é«˜çš„å¯é æ€§** - å¥åº·æ£€æŸ¥ã€è‡ªåŠ¨å¤‡ä»½
3. **æ›´å¼ºçš„å¯è§‚æµ‹æ€§** - ç»“æ„åŒ–æ—¥å¿—ã€ç›‘æ§æŒ‡æ ‡
4. **æ›´å¥½çš„éƒ¨ç½²ä½“éªŒ** - Dockeræ”¯æŒã€å¤šç¯å¢ƒé…ç½®
5. **æ›´é«˜çš„æ€§èƒ½** - ç¼“å­˜ã€ä¼˜åŒ–æŸ¥è¯¢

å»ºè®®æŒ‰ç…§ä¼˜å…ˆçº§é€æ­¥å®æ–½ï¼Œæ¯æ¬¡å®æ–½åè¿›è¡Œå……åˆ†æµ‹è¯•ã€‚

---

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0.0
**æœ€åæ›´æ–°**: 2026-01-23
